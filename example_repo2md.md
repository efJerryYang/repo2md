# `repo2md`

## Directory `/`

```sh
|-- .git/
|-- .github/
|-- docs/
|-- src/
|-- .gitignore    [text]
|-- Cargo.toml    [text]
`-- README.md    [text]
```

### Directory `.git/`

```sh
```

### Source file: `.gitignore`

```
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb
```

### Source file: `Cargo.toml`

```toml
[package]
name = "repo2md"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.0", features = ["derive"] }
ignore = "0.4.18"
log = "0.4.14"
env_logger = "0.9.0"
walkdir = "2.3.2"
indicatif = "0.17.0"
strum = { version = "0.24", features = ["derive"] }
strum_macros = "0.24"

[dev-dependencies]
assert_cmd = "2.0.4"
predicates = "2.1.1"
```

### Directory `src/`

```sh
`-- main.rs    [text]
```

### Source file: `src/main.rs`

```rust
use clap::Parser;
use ignore::gitignore::GitignoreBuilder;
use ignore::WalkBuilder;
use indicatif::{ProgressBar, ProgressStyle};
use log::{debug, error, warn};
use std::fs::{self, DirEntry};
use std::path::{Path, PathBuf};
use std::collections::{HashMap, HashSet};
use strum_macros::Display;
use walkdir::WalkDir;

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
struct Cli {
    /// Path to the local repository
    #[clap(value_parser)]
    repo: String,

    /// Patterns of files/directories to include
    #[clap(long, value_parser, num_args = 1..)]
    include: Vec<String>,

    /// Patterns of files/directories to ignore/exclude
    #[clap(long, alias = "exclude", value_parser, num_args = 1..)]
    ignore: Vec<String>,
}

#[derive(Display)]
enum FileType {
    Text,
    Binary,
    SymbolicLink,
}

fn main() {
    env_logger::init();

    let cli = Cli::try_parse();
    let cli = match cli {
        Ok(cli) => cli,
        Err(e) => {
            if e.to_string().contains("not provided") {
                eprintln!("Error: No repository path provided.");
                eprintln!("Hint: Maybe you wanted to say 'repo2md .'?");
                std::process::exit(1);
            } else if e.to_string().contains("Usage") {
                println!("{}", e);
                std::process::exit(0);
            } else {
                eprintln!("{}", e);
                std::process::exit(1);
            }
        }
    };
    
    let repo_path_buf = Path::new(&cli.repo).canonicalize().unwrap();
    let repo_path = repo_path_buf.as_path();

    if !repo_path.exists() {
        error!("Repository path does not exist: {:?}", repo_path);
        std::process::exit(1);
    }

    let mut gitignore = GitignoreBuilder::new(repo_path);

    for ignore_pattern in &cli.ignore {
        let mut pattern = ignore_pattern.clone();
        if pattern.ends_with('/') {
            pattern.push_str("**");
        }
        gitignore.add_line(None, &pattern).unwrap();
    }
    // add `.git/` to the ignore list
    gitignore.add_line(None, ".git/**").unwrap();
    // add content of `.gitignore` to the ignore list
    gitignore.add(repo_path.join(".gitignore"));
    gitignore.add(repo_path.join(".git/info/exclude"));
    debug!("Gitignore: {:?}", &gitignore);

    let include_patterns: Vec<_> = cli.include.iter().map(|p| p.as_str()).collect();
    let walker = WalkBuilder::new(repo_path)
        .standard_filters(false)
        .follow_links(false)
        .git_ignore(true)
        .git_exclude(true)
        .require_git(false)
        .parents(true) // This should allow nested directories with .gitignore (not tested yet)
        .build();

    let repo_name = repo_path.file_name().unwrap().to_str().unwrap();
    let output_file = format!("{}_repo2md.md", repo_name);
    let mut output = String::new();
    output.push_str(&format!("# `{}`\n\n", repo_name));

    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("⠁⠂⠄⡀⢀⠠⠐⠈ ")
            .template("{spinner:.green} [{elapsed_precise}] Traversing {wide_msg}")
            .unwrap(),
    );
    // dbg!(&gitignore);

    let gitignore = gitignore.build().unwrap();
    let mut filtered_entries: HashMap<PathBuf, Vec<DirEntry>> = HashMap::new();
    for entry in walker.filter_map(|e| e.ok()) {
        let path = entry.path();
        let rel_path = path.strip_prefix(repo_path).unwrap();
        let rel_path_buf = rel_path.to_path_buf();
        
        if gitignore.matched(&rel_path_buf, rel_path_buf.is_dir()).is_ignore() && !include_patterns.iter().any(|p| rel_path.starts_with(p)) {
            if path.is_dir() {
                // Skip ignored directories
                WalkDir::new(path).max_depth(1).into_iter().for_each(drop);
            }
            continue;
        }
        // dbg!(path);
        progress_bar.set_message(format!("{}", rel_path.display()));
        if path.is_dir() {
            let mut dir_entries = Vec::new();
            for entry in fs::read_dir(path).unwrap() {
                let entry = entry.unwrap();
                let entry_path = entry.path();
                if !gitignore.matched_path_or_any_parents(&entry_path, entry_path.is_dir()).is_ignore() {
                    dir_entries.push(entry);
                }
            }
            filtered_entries.insert(path.to_path_buf(), dir_entries);
            let dir_name = rel_path.to_str().unwrap();
            let header_level = rel_path.components().count() + 2;
            output.push_str(&format!("{} Directory `{}/`\n\n", "#".repeat(header_level), dir_name));
            // dbg!(path);             
            let mut ignored_dirs = HashSet::new();
            let tree_output = generate_tree_output(&path, &filtered_entries, &mut ignored_dirs);
            output.push_str("```sh\n");
            output.push_str(&tree_output);
            output.push_str("```\n\n");
        } else {
            let file_type = detect_file_type(path);
            // dbg!(path);
            match file_type {
                FileType::Text => {
                    let source_file = rel_path.to_str().unwrap();
                    output.push_str(&format!("### Source file: `{}`\n\n", source_file));

                    let file_extension = path.extension().and_then(|ext| ext.to_str()).unwrap_or("");
                    let code_block_lang = match file_extension {
                        "rs" => "rust",
                        "md" => "markdown",
                        file_extension => file_extension,
                    };

                    output.push_str(&format!("```{}\n", code_block_lang));
                    match fs::read_to_string(path) {
                        Ok(content) => output.push_str(&content),
                        Err(e) => {
                            warn!("Failed to read file: {:?}, error: {}", path, e);
                            // output.push_str("[Failed to read file contents]");
                        }
                    }
                    output.push_str("\n```\n\n");
                }
                FileType::Binary => {
                    warn!("Binary file not ignored by .gitignore: {:?}", rel_path);
                    // output.push_str(&format!("Binary file `{}` detected, consider adding it to .gitignore.\n\n", rel_path.display()));
                }
                FileType::SymbolicLink => {
                    warn!("Symbolic link not ignored by .gitignore: {:?}", rel_path);
                    // output.push_str(&format!("Symbolic link `{}` detected, consider adding it to .gitignore.\n\n", rel_path.display()));
                }
            }
        }

        progress_bar.inc(1);
    }

    progress_bar.finish_and_clear();
    match fs::write(&output_file, output.trim_end().to_string() + "\n") {
        Ok(_) => println!("Markdown output written to: {}", output_file),
        Err(e) => {
            error!("Failed to write output file: {}, error: {}", output_file, e);
            std::process::exit(1);
        }
    }
}
fn generate_tree_output(dir: &Path, filtered_entries: &HashMap<PathBuf, Vec<DirEntry>>, ignored_dirs: &mut HashSet<PathBuf>) -> String {
    let mut output = String::new();
    tree_recursive(dir, 0, filtered_entries, ignored_dirs, &mut output);
    output
}

fn tree_recursive(
    dir: &Path,
    level: usize,
    filtered_entries: &HashMap<PathBuf, Vec<DirEntry>>,
    ignored_dirs: &mut HashSet<PathBuf>,
    output: &mut String,
) {
    let entries = match filtered_entries.get(dir) {
        Some(entries) => entries,
        None => return,
    };

    let mut files = Vec::new();
    let mut dirs = Vec::new();

    for entry in entries {
        let path = entry.path();
        if path.is_dir() {
            dirs.push(entry);
        } else {
            files.push(entry);
        }
    }

    dirs.sort_by(|a, b| a.path().cmp(&b.path()));
    files.sort_by(|a, b| a.path().cmp(&b.path()));

    for (idx, entry) in dirs.iter().enumerate() {
        let path = entry.path();
        if ignored_dirs.contains(&path) {
            continue;
        }
        let name = path.file_name().unwrap().to_str().unwrap();

        let prefix = if idx == dirs.len() - 1 && files.is_empty() {
            "`-- "
        } else {
            "|-- "
        };

        output.push_str(&format!("{}{}{}/\n", "    ".repeat(level), prefix, name));
        tree_recursive(&path, level + 1, filtered_entries, ignored_dirs, output);
    }

    for (idx, entry) in files.iter().enumerate() {
        let path = entry.path();
        if ignored_dirs.contains(&path) {
            continue;
        }
        let name = path.file_name().unwrap().to_str().unwrap();

        let file_type = detect_file_type(&path);
        let file_type_str = match file_type {
            FileType::Text => "[text]",
            FileType::Binary => "[binary]",
            FileType::SymbolicLink => "[symlink]",
        };

        let prefix = if idx == files.len() - 1 {
            "`-- "
        } else {
            "|-- "
        };

        output.push_str(&format!("{}{}{}    {}\n", "    ".repeat(level), prefix, name, file_type_str));
    }
}

fn detect_file_type(path: &Path) -> FileType {
    if path.is_symlink() {
        FileType::SymbolicLink
    } else {
        match fs::read(path) {
            Ok(content) => {
                if std::str::from_utf8(&content).is_ok() {
                    FileType::Text
                } else {
                    FileType::Binary
                }
            }
            Err(_) => FileType::Binary,
        }
    }
}

```

### Directory `docs/`

```sh
`-- spec.md    [text]
```

### Source file: `docs/spec.md`

```markdown
# Requirements Specification for Repository-to-Markdown Conversion Tool

## 1. Introduction

This document outlines the requirements for a Command Line Interface (CLI) tool that converts code repositories into a markdown format. The primary purpose is to provide a readable snapshot of the repository's structure and contents, considering ignore patterns specified in `.gitignore` and `.git/info/exclude` files, as well as user-defined include and exclude options.

## 2. Tool Functionality

### 2.1 Basic Conversion

- **Input**: The tool must accept `--repo` as a cli argument to specify the path to the local repository to be converted. It should allow optional `--include` and `--ignore`/`--exclude` arguments to specify patterns of files/directories to be included or excluded from the output.
- **Markdown Format**: The output should include:
  - A header for each directory.
  - An ASCII tree structure of the directory's contents. Just like running `tree --charset=ascii` in the repository's root directory and filtered by the include/exclude patterns.
  - File related path to the project root should be marked with backticks for readability in the `#` headers, the level of the header should be the same as the directory level. `# Project Name` should be the root directory of the repository.

Example of the expected output format:

```markdown
# `Project Name`

## Directory `src/`

```sh
src/
|-- main.rs
|-- parser
|   |-- ast.rs
|   |-- eval.rs
|   |-- grammar.pest
|   `-- visitor.rs
|-- parser.rs
|-- solver
|   |-- baseline_solver.rs
|   `-- egg_solver.rs
`-- solver.rs
```

### Source file: `main.rs`

```rust
// Contents of main.rs
```

### Source file: `parser/ast.rs`

```rust
// Contents of ast.rs
```

...

### 2.2 `.gitignore` and `.git/info/exclude` Handling

- The tool must automatically respect `.gitignore` and `.git/info/exclude` files in the same manner as `git`. This includes all levels of `.gitignore` files in subdirectories and the repository's root `.gitignore` and `.git/info/exclude` files.
- Ignore patterns must apply to both the generation of the directory tree and the inclusion of file contents in the markdown output.

### 2.3 Include and Exclude Options

- **Include/Exclude Options**: The tool should support `--include` and `--ignore` command-line options to manually specify patterns of files/directories to be included or excluded from the output. These options should override patterns from `.gitignore` and `.git/info/exclude` files.
- **Priority**: Later command-line options must override earlier ones. For instance, if a directory is specified to be ignored initially but included later in the command-line arguments, it should be included in the output. The patterns should be applied dynamically during the directory traversal, considering `.gitignore`, `.git/info/exclude`, and command-line arguments for each directory. For nested directories, the tool should handle settings in a way similar to a parent git repository, with inner directory settings overriding outer directory settings if applicable.

### 2.4 CLI Interface

- The tool should be implemented using the Clap library for Rust to manage command-line arguments efficiently.
- The interface must be user-friendly, providing helpful error messages and a usage guide when the commands are not correctly specified.

### 2.5 Binary Files and Symbolic Links Handling

- Binary files and symbolic links should be ignored by default, respecting the user's repository `.gitignore` settings. However, if binary files or symbolic links are not properly ignored, the tool should detect them and provide a warning message in the final output, suggesting the user to include them in the `.gitignore` file or use the `--include` command to force include them if necessary.
- The file types can be marked in the tree structure, e.g., "`--- file.rs [text]`". An enum can be defined for file types, and the `strum` crate can be used for enum iteration and conversion.

### 2.6 Output File Naming

- The output file name should be based on the repository name, which can be extracted using a command like `basename path`, where `path` is the specified repository path.
- The output file name should be in the format "repository name + `-code.md`".

## 3. Technical Considerations

### 3.1 Language and Libraries

- **Language**: Rust, to leverage its performance and safety features, especially considering file system operations and pattern matching.
- **Libraries**:
  - Clap for parsing command-line arguments.
  - A suitable Rust crate for reading and applying `.gitignore` and `.git/info/exclude` patterns, such as `ripgrep`, with additional logic implemented to handle the `.git/info/exclude` file if not supported by the crate.
  - A Rust library or custom implementation to generate ASCII tree structures similar to the `tree` command.

### 3.2 Performance and Error Handling

- The tool must handle large repositories efficiently, minimizing the performance impact of directory traversal and file reading.
- A progress bar or dynamic traversal progress should be displayed in the console, showing the current traversed directory, the number of files to be handled in that directory, and the current number of handled files without scrolling down to the next line of output.
- Proper error handling must be implemented for file access issues, invalid command-line arguments, and unsupported repository structures.
- Error messages should be displayed on the console.
- Log levels:
  - Development mode: DEBUG
  - Production mode: WARNING

## 4. Output Specification

- **Markdown Output**:
  - File names should be marked with backticks for readability.
  - Directory names should be included as headers.
  - File contents should be enclosed in code blocks, with language directly inferred from the file extension.
- **File Naming**: The output file name should be "repository name + `-code.md`", where the repository name is determined by the directory name of the repository's root.

## 5. Future Considerations

- **Testing**: The tool should be thoroughly tested using unit tests, integration tests, and end-to-end tests. The desired code coverage and specific testing frameworks or libraries will be specified in the future.
- **Documentation**: Proper documentation should be provided, including a README file with installation instructions, usage examples, and any necessary dependencies. The desired level of code documentation (e.g., inline comments, function/module-level documentation) will be specified to ensure clarity and maintainability.
- **Performance Benchmarking**: Performance benchmarking requirements will be defined in the future, including the expected maximum repository size the tool should handle, the desired processing time for different repository sizes, and any specific performance metrics to be measured.
- **Continuous Integration and Deployment**: If the tool is intended to be part of a larger development workflow, requirements for continuous integration and deployment will be specified, including the CI/CD pipeline, target platforms or environments, and necessary integration with version control systems or build tools.

By addressing these requirements, the Repository-to-Markdown Conversion Tool will provide a comprehensive and user-friendly solution for converting code repositories into a readable markdown format, considering various ignore patterns and user-defined options.
```

### Source file: `README.md`

```markdown
# Repository to Markdown (repo2md)

> Credit to Claude-3

## Usage

```bash
Usage: repo2md <REPO> [OPTIONS]

Arguments:
  <REPO>  Path to the local repository

Options:
      --include          <INCLUDE>...  Patterns of files/directories to include
      --ignore/--exclude <IGNORE>...   Patterns of files/directories to ignore/exclude
  -h, --help                           Print help
  -V, --version                        Print version
```

Or clone this project and run with `cargo` from this project root:

```bash
cargo run -- <REPO> [OPTIONS]
```

## Example Output

See [example_repo2md.md](example_repo2md.md) for an example of the output of this tool.

```sh
cargo run --  .
# or
repo2md .
```

```

### Directory `.github/`

```sh
`-- workflows/
```

#### Directory `.github/workflows/`

```sh
|-- release/
`-- release.yml    [text]
```

##### Directory `.github/workflows/release/`

```sh
|-- macos.yml    [text]
|-- ubuntu.yml    [text]
`-- windows.yml    [text]
```

### Source file: `.github/workflows/release/ubuntu.yml`

```yml
# name: Release Ubuntu

# on:
#   push:
#     tags:
#       - 'v*'

# jobs:
#   release-ubuntu:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v2
      
#       - name: Set up Rust
#         uses: actions-rs/toolchain@v1
#         with:
#           toolchain: stable
#           target: x86_64-unknown-linux-gnu
#           override: true

#       - name: Build
#         uses: actions-rs/cargo@v1
#         with:
#           command: build
#           args: --release --target x86_64-unknown-linux-gnu

#       - name: Rename binary for release
#         run: |
#           mv ./target/x86_64-unknown-linux-gnu/release/repo2md ./target/x86_64-unknown-linux-gnu/release/repo2md-x86_64-unknown-linux-gnu

```

### Source file: `.github/workflows/release/windows.yml`

```yml
# name: Release Windows

# on:
#   push:
#     tags:
#       - 'v*'

# jobs:
#   release-windows:
#     runs-on: windows-latest
#     steps:
#       - uses: actions/checkout@v2
      
#       - name: Set up Rust
#         uses: actions-rs/toolchain@v1
#         with:
#           toolchain: stable
#           target: x86_64-pc-windows-msvc
#           override: true

#       - name: Build
#         uses: actions-rs/cargo@v1
#         with:
#           command: build
#           args: --release --target x86_64-pc-windows-msvc

#       - name: Rename binary for release
#         run: |
#           mv ./target/x86_64-pc-windows-msvc/release/repo2md.exe ./target/x86_64-pc-windows-msvc/release/repo2md-x86_64-pc-windows-msvc.exe

```

### Source file: `.github/workflows/release/macos.yml`

```yml
# name: Release macOS

# on:
#   push:
#     tags:
#       - 'v*'

# jobs:
#   release-macos:
#     runs-on: macos-latest
#     steps:
#       - uses: actions/checkout@v2
      
#       - name: Set up Rust
#         uses: actions-rs/toolchain@v1
#         with:
#           toolchain: stable
#           target: x86_64-apple-darwin
#           override: true

#       - name: Build
#         uses: actions-rs/cargo@v1
#         with:
#           command: build
#           args: --release --target x86_64-apple-darwin

#       - name: Rename binary for release
#         run: |
#           mv ./target/x86_64-apple-darwin/release/repo2md ./target/x86_64-apple-darwin/release/repo2md-x86_64-apple-darwin

#       - name: Create Release
#         id: create_release
#         if: github.ref == 'refs/heads/main'
#         uses: actions/create-release@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           tag_name: ${{ github.ref }}
#           release_name: Release ${{ github.ref }}
#           draft: false
#           prerelease: false

#       - name: Upload Release Asset
#         uses: actions/upload-release-asset@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           upload_url: ${{ steps.create_release.outputs.upload_url }}
#           asset_path: ./target/x86_64-apple-darwin/release/repo2md-x86_64-apple-darwin
#           asset_name: repo2md-x86_64-apple-darwin
#           asset_content_type: application/octet-stream

```

### Source file: `.github/workflows/release.yml`

```yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./target/release/repo2md
          asset_name: repo2md
          asset_content_type: application/octet-stream
```
